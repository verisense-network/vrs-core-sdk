// main.rs
use clap::Parser;
use glob::glob;
use serde_json::{from_str, to_string_pretty, Value};
use std::fs::{self, File};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::process::exit; // For finding files with a pattern

/// nucleus-abigen: Merges JSON export files generated by Nucleus projects
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    /// Root path of the Nucleus project
    #[clap(short, long, value_parser, default_value = ".")]
    path: PathBuf,

    /// Output path for the merged exports.json file
    #[clap(short, long, value_parser, default_value = "./exports.json")]
    output: PathBuf,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    // 1. Print user instructions
    println!("\nImportant Notes:");
    println!("1. Please ensure you are in the root directory of your Nucleus project (the path specified by --path, defaults to the current directory).");
    println!("2. Please compile your Nucleus project first, especially the wasm target, for example by running:");
    println!("   cargo clean && cargo build --release --target wasm32-unknown-unknown");
    println!(
        "   (This will ensure the target/json_exports/ directory and its contents are generated)\n"
    );

    // 2. Construct the path to the directory containing the target JSON files
    let project_path = match fs::canonicalize(&args.path) {
        Ok(p) => p,
        Err(e) => {
            eprintln!(
                "Error: The specified project path '{}' is invalid or does not exist: {}",
                args.path.display(),
                e
            );
            exit(1);
        }
    };

    let json_exports_dir = project_path.join("target").join("json_exports");

    if !json_exports_dir.exists() || !json_exports_dir.is_dir() {
        eprintln!(
            "Error: Directory '{}' does not exist.",
            json_exports_dir.display()
        );
        eprintln!("Please ensure you have compiled the project correctly and the JSON files have been generated in this directory.");
        exit(1);
    }

    println!(
        "Searching for JSON files in directory '{}'...",
        json_exports_dir.display()
    );

    // 3. Find all matching JSON files
    // Construct the glob pattern, e.g., /path/to/project/target/json_exports/__export_json_crate_*.json
    let pattern = json_exports_dir.join("__export_json_crate_*.json");
    let pattern_str = pattern
        .to_str()
        .ok_or("Path pattern contains invalid UTF-8 characters")?;

    let mut all_json_entries: Vec<Value> = Vec::new();
    let mut found_files_count = 0;

    for entry in glob(pattern_str)? {
        match entry {
            Ok(path) => {
                found_files_count += 1;
                println!("Processing file: {}", path.display());

                let mut file_content = String::new();
                File::open(&path)?.read_to_string(&mut file_content)?;

                // Assume each file contains a JSON array
                match from_str::<Vec<Value>>(&file_content) {
                    Ok(json_array) => {
                        all_json_entries.extend(json_array);
                    }
                    Err(e) => {
                        eprintln!("Warning: Failed to parse file '{}', content may not be a valid JSON array: {}", path.display(), e);
                        eprintln!(
                            "File content preview (first 100 characters): {:.100}",
                            file_content
                        );
                        // You can choose to skip this file or panic here
                        // continue;
                    }
                }
            }
            Err(e) => eprintln!(
                "Warning: Error encountered while processing glob pattern: {:?}",
                e
            ),
        }
    }

    if found_files_count == 0 {
        println!("Warning: No JSON files matching the pattern '__export_json_crate_*.json' were found in '{}'.", json_exports_dir.display());
        println!("An empty exports.json will be generated.");
    } else {
        println!("Processed a total of {} JSON files.", found_files_count);
    }

    // 4. Write the merged data to the output file
    let output_path = if args.output.is_absolute() {
        args.output.clone()
    } else {
        // If it's a relative path, resolve it against the current working directory
        std::env::current_dir()?.join(args.output)
    };

    // Ensure the output directory exists
    if let Some(parent_dir) = output_path.parent() {
        fs::create_dir_all(parent_dir)?;
    }

    let final_json_string = to_string_pretty(&all_json_entries)?;
    let mut output_file = File::create(&output_path)?;
    output_file.write_all(final_json_string.as_bytes())?;

    println!(
        "Success! Merged JSON has been written to: {}",
        output_path.display()
    );

    Ok(())
}
